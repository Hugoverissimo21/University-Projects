<!DOCTYPE html>
<html lang="en"><head>
<script src="ani_quarto_files/libs/clipboard/clipboard.min.js"></script>
<script src="ani_quarto_files/libs/quarto-html/tabby.min.js"></script>
<script src="ani_quarto_files/libs/quarto-html/popper.min.js"></script>
<script src="ani_quarto_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="ani_quarto_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ani_quarto_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="ani_quarto_files/libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="ani_quarto_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.433">

  <meta name="author" content="Hugo Veríssimo">
  <meta name="author" content="Lara Pereira">
  <meta name="author" content="Miriam Marques">
  <title>Regressão Exponencial</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="ani_quarto_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="ani_quarto_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="ani_quarto_files/libs/revealjs/dist/theme/quarto.css">
  <link rel="stylesheet" href="mystyle.css">
  <link href="ani_quarto_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="ani_quarto_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="ani_quarto_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="ani_quarto_files/libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="ani_quarto_files/libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="ani_quarto_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    margin-bottom: 0.5rem;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Regressão Exponencial</h1>
  <p class="subtitle">Otimização</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Hugo Veríssimo 
</div>
</div>
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Lara Pereira 
</div>
</div>
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Miriam Marques 
</div>
</div>
</div>

</section>
<section>
<section id="introdução" class="title-slide slide level1 center">
<h1>Introdução</h1>

</section>
<section id="introdução-1" class="slide level2 justify">
<h2>Introdução</h2>
<p>A função exponencial é a “função mais importante da matemática” [Rudin, 1987]. Esta possui aplicações em áreas como: economia, probabilidades, estatística, biologia, física, medicina, engenharia, entre outras.</p>
<p>O crescimento populacional, analisado geralmente através da construção e interpretação de gráficos de dados macroeconómicos, pode ser explicado através das propriedades algébricas e gráficas das funções exponenciais e logarítmicas para o cálculo e interpretação de taxas de crescimento populacional através de séries temporais.</p>
<p>O número de Euler é também muito aplicado nas finanças, principalmente em cálculos de juros compostos, onde a riqueza cresce a uma taxa definida ao longo do tempo.</p>
</section>
<section id="introdução-2" class="slide level2 justify">
<h2>Introdução</h2>
<p>Um comum problema computacional é o do cálculo da solução para problemas de mínimos quadrados, que possui grande importância numa ampla gama de campos que vão desde a álgebra linear até à econometria e otimização. A função exponencial será utilizada como título exemplificativo para a resolução de sistemas não lineares de equações no presente trabalho. Neste, iremos apresentar algoritmos numericamente estáveis e computacionalmente eficientes para calcular a solução do problema de mínimos quadrados.</p>
<p>A descoberta do vetor de parâmetros que minimiza a função objetivo pode ser realizada com recurso a várias técnicas. No presente trabalho serão abordadas duas das mesmas, a decomposição QR e o método de Levenberg-Marquardt.</p>
</section>
<section id="introdução-3" class="slide level2 justify">
<h2>Introdução</h2>
<p>A decomposição QR foi considerada um dos 10 algoritmos com maior influência no desenvolvimento e na prática da ciência e da engenharia no século XX.</p>
<p>Contudo, a crescente complexidade da produção industrial aumenta os requisitos de precisão e velocidade.</p>
<p>Métodos de resolução de sistemas não lineares como o de Levenberg-Marquardt e evoluções destes são essenciais para assegurar a satisfação da crescente procura por uma otimização mais eficiente.</p>
</section></section>
<section>
<section id="decomposição-qr" class="title-slide slide level1 center">
<h1>Decomposição QR</h1>

</section>
<section id="decomposição-qr-1" class="slide level2 justify">
<h2>Decomposição QR</h2>
<p>A decomposição QR é utilizada para a resolução de sistemas sobredeterminados, através do método dos mínimos quadrados.</p>
<p>A decomposição QR tem como objetivo expressar uma matriz <span class="math inline">\(A\in \mathbb{M}_{m,n} (\mathbb{R})\)</span> no produto de duas matrizes, tal que: <span class="math display">\[\begin{equation}
A=QR
\end{equation}\]</span> onde <span class="math inline">\(Q\in \mathbb{M}_{m,n} (\mathbb{R})\)</span> é uma matriz cujas colunas formam uma base ortonormada para o espaço das colunas de A (isto é, <span class="math inline">\(Q^T Q = I_n\)</span>) e <span class="math inline">\(R\in \mathbb{M}_{n,n} (\mathbb{R})\)</span> é uma matriz invertível, triangular superior com entradas diagonais positivas.</p>
</section>
<section id="processo-de-ortonormalização-de-gram-schmidt" class="slide level2 justify">
<h2>Processo de Ortonormalização de Gram-Schmidt</h2>
<!-- dizer que existem varios processos para o qr, vamos usar o GS -->
<p>A aplicação do processo de ortonormalização de Gram-Schmidt requer a utilização dos vetores que correspondem às colunas da matriz A. <span class="math display">\[\begin{equation}
A=[a_1|a_2|...|a_n]
\end{equation}\]</span> Dois passos essenciais do processo referido são a ortogonalização e a normalização. A realização da ortogonalização tem como intuito a transformação do conjunto de vetores linearmente independentes num conjunto ortogonal, onde cada vetor é ortogonal (perpendicular) aos outros. A normalização transforma este conjunto ortogonal num conjunto ortonormal, isto é, cada vetor possui norma igual a 1.</p>
</section>
<section id="processo-de-ortonormalização-de-gram-schmidt-1" class="slide level2 justify">
<h2>Processo de Ortonormalização de Gram-Schmidt</h2>
<p><span class="math display">\[\begin{multline}
\begin{aligned}
&amp; \text{Ortogonalização} &amp;&amp; \text{Normalização} \\
&amp; v_1 = a_1, &amp;&amp; q_1 = \frac{v_1}{\|v_1\|_2} \\
&amp; v_2 = a_2 - (q_1^T \cdot a_2) q_1, &amp;&amp; q_2 = \frac{v_2}{\|v_2\|_2} \\
&amp; v_3 = a_3 - (q_1^T \cdot a_3) q_1 - (q_2^T \cdot a_3) q_2, &amp;&amp; q_3 = \frac{v_3}{\|v_3\|_2} \\
&amp; \vdots &amp;&amp; \hspace{7.65cm} \\
&amp; v_n = a_n - (q_1^T \cdot a_n) q_1 - \ldots - (q_{n-1}^T \cdot a_n) q_{n-1}, &amp;&amp; q_n = \frac{v_n}{\|v_n\|_2}
\end{aligned}
\end{multline}\]</span></p>
</section>
<section id="algoritmo-de-gram-schmidt-clássico" class="slide level2 justify">
<h2>Algoritmo de Gram-Schmidt Clássico</h2>
<p>Note-se que após o processo de ortogonalização e normalização, obtém-se a decomposição QR da matriz A:</p>
<p><span class="math display">\[\begin{equation}
A = [q_1| q_2|...| q_n]
\begin{bmatrix}
\|v_1\|_2 &amp; q_1^T\cdot a_2 &amp;...&amp; q_1^T\cdot a_n \\
0 &amp; \|v_2\|_2 &amp;...&amp; q_2^T\cdot a_n \\
\vdots &amp; \vdots &amp; \ddots &amp;\vdots \\
0 &amp; 0 &amp;...&amp; \|v_n\|_2
\end{bmatrix}
= QR
\end{equation}\]</span></p>
</section>
<section id="implementação-em-python" class="slide level2 justify">
<h2>Implementação em Python</h2>
<div class="sourceCode" id="cb1" data-code-line-numbers="1-10|11-12|14-26|28-33|35-38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">def</span> QRdecomposition_Gram_Schmidt(A):</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="co">"""</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">    entrada:</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">        A - matriz a decompor</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">    saída:</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">        Q - matriz ortogonal</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">        R - matriz triangular superior</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">    """</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    q <span class="op">=</span> [] <span class="co">#sera a lista de colunas de Q</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    R <span class="op">=</span> np.zeros((<span class="bu">len</span>(A[<span class="dv">0</span>]), <span class="bu">len</span>(A[<span class="dv">0</span>])), dtype<span class="op">=</span><span class="bu">float</span>) <span class="co"># matriz R, preenchida de zeros</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="co"># percorrer as colunas da matriz A</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(np.transpose(A))):</span>
<span id="cb1-16"><a href="#cb1-16"></a>        ai <span class="op">=</span> np.transpose(A)[i] <span class="co">#ai = coluna i de A</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a>        projecoes <span class="op">=</span> <span class="dv">0</span> <span class="co">#a subtrair no calculo de vi</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>        <span class="co"># percorrer as colunas Q ja calculadas</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(q)):</span>
<span id="cb1-21"><a href="#cb1-21"></a>            qn <span class="op">=</span> q[n] <span class="co">#qn = coluna n de Q, ja calculada, pelo que n &lt; i</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>            R[n][i] <span class="op">=</span> np.inner(qn,ai) <span class="co">#calcular r_{n,i}</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>            projecoes <span class="op">+=</span> R[n][i]<span class="op">*</span>qn <span class="co">#somar as projecoes a subtrair a ai</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>        </span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="co"># calcular vi</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        vi <span class="op">=</span> ai <span class="op">-</span> projecoes</span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a>        <span class="co"># calcular r_{i,i}: norma 2 de vi</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>        R[i][i] <span class="op">=</span> np.sqrt(np.inner(vi,vi))</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>        <span class="co"># calcular qi: normalizacao de vi</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>        qi <span class="op">=</span> vi<span class="op">/</span>R[i][i]</span>
<span id="cb1-33"><a href="#cb1-33"></a>        q.append(qi)</span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="co"># converter q numa matriz (Q') e transpor</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    Q <span class="op">=</span> np.transpose(np.vstack(q))</span>
<span id="cb1-37"><a href="#cb1-37"></a></span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="cf">return</span> Q,R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="regressão-exponencial" class="slide level2 justify">
<h2>Regressão Exponencial</h2>
<p>Pretende-se utilizar a decomposição QR para estimar os parâmetros que otimizam, no sentido dos mínimos quadrados, uma função exponencial <span class="math inline">\(y(x)\)</span>: <span class="math display">\[\begin{equation}
y(x)=\beta_{0} e^{\beta_{1}x}
\end{equation}\]</span></p>
<p>Todavia, a função <span class="math inline">\(y(x)\)</span> não é linear pelo que não é possível obter a matriz <span class="math inline">\(A\)</span>, impossibilitando a aplicação da decomposição QR. Por esse motivo, terão que ser realizadas transformações na expressão com o objetivo de linearizar a mesma.</p>
</section>
<section id="linearização-do-problema" class="slide level2 justify">
<h2>Linearização do Problema</h2>
<p>Aplicando logaritmos, <span class="math display">\[\begin{equation}
ln(y(x))=ln(\beta_{0} e^{\beta_{1}x})
\end{equation}\]</span></p>
<p>Através das propriedades dos logaritmos, <span class="math display">\[\begin{equation}
ln(y(x))=ln(\beta_{0}) + \beta_{1}x
\end{equation}\]</span></p>
<p><span class="math inline">\(\ \)</span></p>
<p>Assumindo <span class="math inline">\(P(x)=ln(y(x))\)</span>, <span class="math inline">\(a_0=ln(\beta_{0})\)</span> e <span class="math inline">\(a_1=\beta_{1}\)</span>, tem-se <span class="math display">\[\begin{equation}
P(x)=a_0 + a_1x
\end{equation}\]</span></p>
<p>Uma vez obtida a função <span class="math inline">\(y(x)\)</span> como combinação linear de funções, a fase de linearização está completa.</p>
</section>
<section id="resolução-do-problema" class="slide level2 justify">
<h2>Resolução do Problema</h2>
<p>A descoberta dos parâmetros passa pela resolução do sistema <span class="math inline">\(Ax=b\)</span>, onde <span class="math inline">\(A\)</span> é a matriz de coeficientes dos parâmetros a estimar do sistema de equações, <span class="math inline">\(x\)</span> é o vetor solução dos parâmetros a estimar e <span class="math inline">\(b\)</span> é o vetor que contém as variáveis resposta do sistema de equações.</p>
<p>Aplicando a decomposição QR à matriz <span class="math inline">\(A\)</span> obtém-se <span class="math inline">\(QR=A\)</span>, pelo que podem ser efetuadas as seguintes equivalências matriciais: <span class="math display">\[\begin{equation}
Ax=b \Leftrightarrow QRx=b \Leftrightarrow Q^TQRx=Q^Tb \Leftrightarrow IRx=Q^Tb \Leftrightarrow Rx=Q^Tb
\end{equation}\]</span> Sendo assim, a resolução do sistema de equações <span class="math inline">\(Ax=b\)</span>, para a obtenção do vetor <span class="math inline">\(x\)</span> dos parâmetros, passa pela resolução do sistema <span class="math inline">\(Rx=Q^Tb\)</span>.</p>
</section>
<section id="resolução-do-problema-1" class="slide level2 justify">
<h2>Resolução do problema</h2>
<p><span class="math inline">\(\ \)</span></p>
<p><span class="math display">\[\begin{equation}
\begin{split}
Ax=b
&amp; \Leftrightarrow
\begin{bmatrix}
1 &amp; x_1 \\ 1 &amp; x_2 \\ \vdots &amp; \vdots \\ 1 &amp; x_n
\end{bmatrix}
\begin{bmatrix}
ln(\beta_0) \\ \beta_1
\end{bmatrix}
=
\begin{bmatrix}
ln(y_1) \\ ln(y_2) \\ \vdots \\ ln(y_n)
\end{bmatrix} \\
&amp; \\
&amp; \Leftrightarrow
R
\begin{bmatrix}
ln(\beta_0) \\ \beta_1
\end{bmatrix}
=
Q^T
\begin{bmatrix}
ln(y_1) \\ ln(y_2) \\ \vdots \\ ln(y_n)
\end{bmatrix}
\end{split}
\end{equation}\]</span></p>
</section>
<section id="exemplo---regressão-exponencial-problema-linearizado-qr" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Linearizado (QR)</h2>
<p>Dado o seguinte conjunto de pontos acerca do Bangladesh, pretende-se analisar o crescimento exponencial do Rendimento Nacional Bruto (RNB) do mesmo de 2000 a 2019. Os valores de <span class="math inline">\(x\)</span> correspondem aos anos e os valores de <span class="math inline">\(y\)</span> ao RNB (em unidades por milhares de milhões de dólares).</p>
<p><span class="math inline">\(\ \)</span></p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(0\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(y_i\)</span></td>
<td><span class="math inline">\(175.5\)</span></td>
<td><span class="math inline">\(188.1\)</span></td>
<td><span class="math inline">\(200.2\)</span></td>
<td><span class="math inline">\(213.7\)</span></td>
<td><span class="math inline">\(231.6\)</span></td>
<td><span class="math inline">\(254.7\)</span></td>
<td><span class="math inline">\(283.1\)</span></td>
<td><span class="math inline">\(313.5\)</span></td>
<td><span class="math inline">\(342.9\)</span></td>
<td><span class="math inline">\(363.7\)</span></td>
</tr>
</tbody>
</table>
<hr>
<hr>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(10\)</span></th>
<th><span class="math inline">\(11\)</span></th>
<th><span class="math inline">\(12\)</span></th>
<th><span class="math inline">\(13\)</span></th>
<th><span class="math inline">\(14\)</span></th>
<th><span class="math inline">\(15\)</span></th>
<th><span class="math inline">\(16\)</span></th>
<th><span class="math inline">\(17\)</span></th>
<th><span class="math inline">\(18\)</span></th>
<th><span class="math inline">\(19\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(y_i\)</span></td>
<td><span class="math inline">\(389.1\)</span></td>
<td><span class="math inline">\(422.2\)</span></td>
<td><span class="math inline">\(481.1\)</span></td>
<td><span class="math inline">\(518.8\)</span></td>
<td><span class="math inline">\(555.1\)</span></td>
<td><span class="math inline">\(591.6\)</span></td>
<td><span class="math inline">\(643.1\)</span></td>
<td><span class="math inline">\(693.0\)</span></td>
<td><span class="math inline">\(767.3\)</span></td>
<td><span class="math inline">\(846.1\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="exemplo---regressão-exponencial-problema-linearizado-qr-1" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Linearizado (QR)</h2>
<p>A amostra de dados pode ser explicada pela função <span class="math inline">\(y(x)=\beta_{0} e^{\beta_{1}x}\)</span>, pelo que se pretende obter o vetor de parâmetros que minimiza a soma dos quadrados dos resíduos, através da aplicação da decomposição QR.</p>
<p>A função <span class="math inline">\(y(x)\)</span> já foi linearizada anteriormente, obtendo-se <span class="math display">\[\begin{equation}
ln(y(x))=ln(\beta_{0}) + \beta_{1}x
\end{equation}\]</span> <!-- meti centrado pq mudava de linha e ficava feio, tem mal ? --></p>
<p>De seguida, os pontos referidos são aplicados à expressão obtida. A dedução do vetor de parâmetros que contém <span class="math inline">\(\beta_{0}\)</span> e <span class="math inline">\(\beta_{1}\)</span> passa pela resolução do sistema sobredeterminado <span class="math inline">\(Ax=b\)</span>, através do seguinte algoritmo elaborado:</p>
</section>
<section id="exemplo---regressão-exponencial-problema-linearizado-qr-2" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Linearizado (QR)</h2>
<div class="sourceCode" id="cb2" data-code-line-numbers="1-4|5-7|8-9|11-13|15-16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>x <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">19</span> <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb2-2"><a href="#cb2-2"></a>y <span class="op">=</span> [np.log(value) <span class="cf">for</span> value <span class="kw">in</span> [<span class="fl">175.5</span>, <span class="fl">188.1</span>, <span class="fl">200.2</span>, <span class="fl">213.7</span>, <span class="fl">231.6</span>, <span class="fl">254.7</span>, <span class="fl">283.1</span>,</span>
<span id="cb2-3"><a href="#cb2-3"></a>                                 <span class="fl">313.5</span>, <span class="fl">342.9</span>, <span class="fl">363.7</span>, <span class="fl">389.1</span>, <span class="fl">422.2</span>, <span class="fl">481.1</span>, <span class="fl">518.8</span>,</span>
<span id="cb2-4"><a href="#cb2-4"></a>                                 <span class="fl">555.1</span>, <span class="fl">591.6</span>, <span class="fl">643.1</span>, <span class="fl">693.0</span>, <span class="fl">767.3</span>, <span class="fl">846.1</span>]]</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># Ax = b; x = [ln(b0), b1]</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>A <span class="op">=</span> np.column_stack((np.ones(<span class="bu">len</span>(x)), x))</span>
<span id="cb2-7"><a href="#cb2-7"></a>b <span class="op">=</span> np.array(y).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb2-8"><a href="#cb2-8"></a>Q, R <span class="op">=</span> QRdecomposition_Gram_Schmidt(A)  <span class="co"># QRx = b</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>Rx <span class="op">=</span> np.dot(np.transpose(Q), b)  <span class="co"># Rx = Qt*b</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>x <span class="op">=</span> np.zeros(<span class="bu">len</span>(R))</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(R) <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-13"><a href="#cb2-13"></a>    x[i] <span class="op">=</span> (Rx[i, <span class="dv">0</span>] <span class="op">-</span> np.dot(R[i, i <span class="op">+</span> <span class="dv">1</span>:], x[i <span class="op">+</span> <span class="dv">1</span>:])) <span class="op">/</span> R[i, i]</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a>b0, b1 <span class="op">=</span> np.exp(x[<span class="dv">0</span>]), x[<span class="dv">1</span>]</span>
<span id="cb2-16"><a href="#cb2-16"></a>b0, b1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>(171.00724094657875, 0.08356097087277026)</code></pre>
</div>
</div>
<p>A função que minimiza os quadrados dos resíduos é <span class="math inline">\(y = 171.0\ e^{0.08356x}\)</span>. <!-- dizer que é pelo qr --></p>
</section>
<section id="exemplo---regressão-exponencial-problema-linearizado-qr-3" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Linearizado (QR)</h2>

<img data-src="realidadevsQR.png" style="width:100.0%" class="r-stretch quarto-figure-center"><p class="caption">Figura 1: Gráfico dos valores observados para a variável explicativa e resposta, em conjunto com o modelo ajustado.</p></section></section>
<section>
<section id="método-de-levenberg-marquardt" class="title-slide slide level1 center">
<h1>Método de <br> Levenberg-Marquardt</h1>

</section>
<section id="método-de-levenberg-marquardt-1" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>Dada uma função não linear nos parâmetros, o problema dos mínimos quadrados requer um algoritmo iterativo. Tais algoritmos reduzem a soma dos quadrados dos erros entre a função do modelo e os pontos dados através de uma sequência de atualizações bem escolhidas nos valores dos parâmetros do modelo.</p>
<p>Para equações não lineares, pode não haver solução, pode haver um qualquer número de soluções, ou um número infinito de soluções. Ao contrário das equações lineares, é um problema computacional muito difícil determinar qual destes casos é válido para um determinado conjunto de equações. Assim sendo, para problemas não lineares, apenas se pode esperar um algoritmo que encontre uma solução (quando existe) ou produza um valor de <span class="math inline">\(x\)</span> com norma residual que seja a menor possível.</p>
</section>
<section id="método-de-levenberg-marquardt-2" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>O algoritmo de Levenberg-Marquardt combina dois algoritmos de minimização numérica: o método de declive máximo e o método de Gauss-Newton.</p>
<p>O problema da regressão exponencial apresentado anteriormente pode também ser resolvido através deste processo, o método de Levenberg-Marquardt. Este não envolve linearização, pelo que pode ser utilizado diretamente em funções não lineares, o que lhe confere uma maior precisão em termos numéricos e robustez para funções não lineares.</p>
</section>
<section id="método-de-levenberg-marquardt-3" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>Por conseguinte, num problema não linear de mínimos quadrados, a função objetivo é a mesma do caso de funções lineares, e consiste na descoberta do vetor de parâmetros <span class="math inline">\(x\)</span> que minimiza: <span class="math display">\[\begin{equation}
g(x)=\frac{1}{2}\ r(x)\ r(x)^T=\frac{1}{2}\sum_{i=1}^{m}r_i(x)^2
\end{equation}\]</span></p>
<p>Apesar de a função objetivo ser igual independentemente da função ser linear ou não, os resíduos <span class="math display">\[\begin{equation}
r_i(x)=y_i-f(x), \quad  i=1,...,m
\end{equation}\]</span> são não lineares, tal como a função <span class="math inline">\(f(x)\)</span>.</p>
</section>
<section id="método-de-levenberg-marquardt-4" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>Note-se que, o gradiente da função objetivo é dado por <span class="math display">\[\begin{equation}
\nabla g(x) = \sum_{i=1}^{m}r_i(x) \cdot \nabla r_i(x) = \nabla r(x)^Tr(x)
\end{equation}\]</span></p>
<p>onde <span class="math display">\[\begin{equation}
\nabla r(x)=\begin{bmatrix}
\frac{\partial r_1(x)}{\partial x_1} &amp; \cdots &amp; \frac{\partial r_1(x)}{\partial x_n} \\
\vdots &amp;  &amp; \vdots \\
\frac{\partial r_m(x)}{\partial x_1} &amp; \cdots &amp; \frac{\partial r_m(x)}{\partial x_n}
\end{bmatrix}
\end{equation}\]</span> é a matriz <span class="math inline">\(m \times n\)</span> Jacobiana do resíduo <span class="math inline">\(r\)</span> em relação aos parâmetros <span class="math inline">\(x\)</span>.</p>
</section>
<section id="método-de-levenberg-marquardt-5" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>O vetor <span class="math display">\[\begin{equation}
\nabla r_i(x)=\begin{bmatrix}
\frac{\partial r_i(x)}{\partial x_1} \\
\vdots \\
\frac{\partial r_i(x)}{\partial x_n}
\end{bmatrix}
\end{equation}\]</span> corresponde à linha <span class="math inline">\(i\)</span> da matriz Jacobiana.</p>
<p>A segunda derivada de <span class="math inline">\(g(x)\)</span> é dada pela matriz Hessiana <span class="math display">\[\begin{equation}
\begin{split}
\nabla^2 g(x) &amp; =\sum_{i=1}^{m}(\nabla r_i(x) \cdot \nabla r_i(x)^T+r_i(x) \cdot \nabla^2 r_i(x))\\
&amp; =\nabla r(x)^T\nabla r(x) + S(x), \quad \text{com } S(x)=\sum_{i=1}^{m}r_i(x) \cdot \nabla^2 r_i(x)
\end{split}
\end{equation}\]</span></p>
</section>
<section id="método-de-levenberg-marquardt-6" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>O método LM sugere a aproximação da matriz <span class="math inline">\(S(x)\)</span> pela matriz <span class="math inline">\(\mu I\)</span> <span class="math display">\[\begin{equation}
(\nabla r(x^{(k)})^T\nabla r(x^{(k)})+\mu^{(k)}I)s^{(k)}_{LM}=-\nabla r(x^{(k)})^T r(x^{(k)})
\end{equation}\]</span></p>
<p>A matriz <span class="math inline">\(\nabla r(x^{(k)})^T\nabla r(x^{(k)})+\mu^{(k)}I\)</span> é simétrica e definida positiva, <span class="math inline">\(n \times n\)</span> (com <span class="math inline">\(n\)</span> igual ao número de parâmetros a estimar).</p>
<p>Pode-se portanto, proceder à resolução do sistema de diversas maneiras, como: a decomposição de Cholesky, a decomposição LU, entre outras, encontrando dessa forma <span class="math inline">\(s^{(k)}_{LM}\)</span>.</p>
<p>O vetor dos parâmetros <span class="math inline">\(x\)</span> será atualizado mediante cada iteração da seguinte forma, <span class="math display">\[\begin{equation}
x^{(k+1)}=x^{(k)}+s^{(k)}_{LM}
\end{equation}\]</span></p>
</section>
<section id="método-de-levenberg-marquardt-7" class="slide level2 justify">
<h2>Método de Levenberg-Marquardt</h2>
<p>A cada iteração, o valor de <span class="math inline">\(x^{(k+1)}\)</span> estará mais próximo do valor ótimo (o que minimiza a soma dos quadrados), pelo que se deve definir uma condição de paragem, podendo esta ser a quantidade de iterações, um valor máximo para a norma do gradiente da função objetivo, <span class="math inline">\(\|\nabla g(x)\|\)</span>, ou um valor máximo para o erro, sendo o erro calculado por exemplo por <span class="math inline">\(\|s^{(k+1)}_{LM}\|_{\infty}\)</span>.</p>
<p>Desta forma, quando é alcançada a precisão desejada o processo iterativo é interrompido, evitando assim iterações desnecessárias e economizando recursos computacionais.</p>
<p>Note-se que o método LM é um método iterativo para otimização não linear, pelo que é imperativo o fornecimento de uma aproximação inicial dos parâmetros do modelo para uma inicialização adequada das iterações do algoritmo.</p>
</section>
<section id="implementação-em-python-1" class="slide level2 justify">
<h2>Implementação em Python</h2>
<div class="sourceCode" id="cb4" data-code-line-numbers="1-10|11-12|14-20|22-24|26-29|31-34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">def</span> LM_iteration(X, Y, ig, miu):</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="co">"""</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">    entrada:</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">        X,Y - conjunto de pontos</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">        ig, miu - aproximacao inicial (b0, b1), parametro mu</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">    saida:</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">        b0, b1 - coeficientes atualizados</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">    """</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    matrix_r <span class="op">=</span> np.zeros((<span class="bu">len</span>(X), <span class="dv">1</span>))  <span class="co"># matriz dos residuos (R)</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    grad_r <span class="op">=</span> np.zeros((<span class="bu">len</span>(X), <span class="dv">2</span>))  <span class="co"># gradiente de R</span></span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a>    b0, b1 <span class="op">=</span> ig</span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="co"># atualizar matrizes</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(X)):</span>
<span id="cb4-17"><a href="#cb4-17"></a>        matrix_r[row, <span class="dv">0</span>] <span class="op">=</span> Y[row] <span class="op">-</span> b0 <span class="op">*</span> np.exp(b1 <span class="op">*</span> X[row])</span>
<span id="cb4-18"><a href="#cb4-18"></a></span>
<span id="cb4-19"><a href="#cb4-19"></a>        grad_r[row, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>np.exp(b1 <span class="op">*</span> X[row])  <span class="co"># r gradiente: col. 1</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>        grad_r[row, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>b0 <span class="op">*</span> X[row]<span class="op">*</span> np.exp(b1 <span class="op">*</span> X[row])  <span class="co"># r gradiente: col. 2</span></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a>    <span class="co"># calcular A(s_LM) = b</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>    A <span class="op">=</span> np.dot(grad_r.T, grad_r) <span class="op">+</span> np.eye(<span class="dv">2</span>) <span class="op">*</span> miu</span>
<span id="cb4-24"><a href="#cb4-24"></a>    b <span class="op">=</span> <span class="op">-</span>np.dot(grad_r.T, matrix_r)</span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="co"># resolver s_LM atraves Cholesky</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>    L <span class="op">=</span> np.linalg.cholesky(A)</span>
<span id="cb4-28"><a href="#cb4-28"></a>    s_LM_y <span class="op">=</span> np.linalg.solve(L, b)</span>
<span id="cb4-29"><a href="#cb4-29"></a>    s_LM <span class="op">=</span> np.linalg.solve(L.T, s_LM_y)</span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a>    <span class="co"># atualizar betas</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>    b0, b1 <span class="op">=</span> <span class="bu">float</span>(b0 <span class="op">+</span> s_LM[<span class="dv">0</span>]), <span class="bu">float</span>(b1 <span class="op">+</span> s_LM[<span class="dv">1</span>])</span>
<span id="cb4-33"><a href="#cb4-33"></a></span>
<span id="cb4-34"><a href="#cb4-34"></a>    <span class="cf">return</span> b0, b1, s_LM</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exemplo---regressão-exponencial-problema-não-linear-lm" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Não Linear (LM)</h2>
<p>Considerando o mesmo conjunto de pontos utilizado na decomposição QR, efetua-se agora uma abordagem diferente do mesmo, recorrendo ao método de Levenberg-Marquardt.</p>
<p><span class="math inline">\(\ \)</span></p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(0\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
<th><span class="math inline">\(6\)</span></th>
<th><span class="math inline">\(7\)</span></th>
<th><span class="math inline">\(8\)</span></th>
<th><span class="math inline">\(9\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(y_i\)</span></td>
<td><span class="math inline">\(175.5\)</span></td>
<td><span class="math inline">\(188.1\)</span></td>
<td><span class="math inline">\(200.2\)</span></td>
<td><span class="math inline">\(213.7\)</span></td>
<td><span class="math inline">\(231.6\)</span></td>
<td><span class="math inline">\(254.7\)</span></td>
<td><span class="math inline">\(283.1\)</span></td>
<td><span class="math inline">\(313.5\)</span></td>
<td><span class="math inline">\(342.9\)</span></td>
<td><span class="math inline">\(363.7\)</span></td>
</tr>
</tbody>
</table>
<hr>
<hr>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(10\)</span></th>
<th><span class="math inline">\(11\)</span></th>
<th><span class="math inline">\(12\)</span></th>
<th><span class="math inline">\(13\)</span></th>
<th><span class="math inline">\(14\)</span></th>
<th><span class="math inline">\(15\)</span></th>
<th><span class="math inline">\(16\)</span></th>
<th><span class="math inline">\(17\)</span></th>
<th><span class="math inline">\(18\)</span></th>
<th><span class="math inline">\(19\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(y_i\)</span></td>
<td><span class="math inline">\(389.1\)</span></td>
<td><span class="math inline">\(422.2\)</span></td>
<td><span class="math inline">\(481.1\)</span></td>
<td><span class="math inline">\(518.8\)</span></td>
<td><span class="math inline">\(555.1\)</span></td>
<td><span class="math inline">\(591.6\)</span></td>
<td><span class="math inline">\(643.1\)</span></td>
<td><span class="math inline">\(693.0\)</span></td>
<td><span class="math inline">\(767.3\)</span></td>
<td><span class="math inline">\(846.1\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="exemplo---regressão-exponencial-problema-não-linear-lm-1" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Não Linear (LM)</h2>
<div class="sourceCode" id="cb5" data-code-line-numbers="1-5|7-16|17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>x <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">19</span> <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb5-2"><a href="#cb5-2"></a>y <span class="op">=</span> [<span class="fl">175.5</span>, <span class="fl">188.1</span>, <span class="fl">200.2</span>, <span class="fl">213.7</span>, <span class="fl">231.6</span>, <span class="fl">254.7</span>, <span class="fl">283.1</span>, <span class="fl">313.5</span>, <span class="fl">342.9</span>, <span class="fl">363.7</span>, <span class="fl">389.1</span>, <span class="fl">422.2</span>,</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="fl">481.1</span>, <span class="fl">518.8</span>, <span class="fl">555.1</span>, <span class="fl">591.6</span>, <span class="fl">643.1</span>, <span class="fl">693.0</span>, <span class="fl">767.3</span>, <span class="fl">846.1</span>]</span>
<span id="cb5-4"><a href="#cb5-4"></a>ig <span class="op">=</span> (<span class="dv">170</span>, <span class="fl">0.0836</span>) <span class="co">#obtido atraves do QR</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>miu <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>iteracoes <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb5-9"><a href="#cb5-9"></a>    b0, b1, s_LM <span class="op">=</span> LM_iteration(x, y, ig, miu)</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="co"># condicao de paragem</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="cf">if</span> <span class="bu">max</span>(<span class="bu">abs</span>(s_LM)) <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">*</span><span class="dv">10</span><span class="op">**</span>(<span class="op">-</span><span class="dv">6</span>):</span>
<span id="cb5-13"><a href="#cb5-13"></a>            <span class="cf">break</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    </span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="co"># atualizar parametros</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>    ig, miu, iteracoes <span class="op">=</span> (b0, b1), <span class="fl">0.1</span>, iteracoes <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>iteracoes, b0, b1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>(4, 171.5072875301047, 0.08333471235500428)</code></pre>
</div>
</div>
</section>
<section id="exemplo---regressão-exponencial-problema-não-linear-lm-2" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Não Linear (LM)</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>iteracoes, b0, b1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(4, 171.5072875301047, 0.08333471235500428)</code></pre>
</div>
</div>
<p>Assim, após o algoritmo de Levenberg-Marquardt realizar 4 iterações, a função que minimiza os quadrados dos resíduos, de acordo com o mesmo, é dada por aproximadamente <span class="math inline">\(y = 171.5\ e^{0.08333x}\)</span>.</p>
</section>
<section id="exemplo---regressão-exponencial-problema-não-linear-lm-3" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Não Linear (LM)</h2>
<p>Podemos confirmar este resultado através da aplicação da função <span class="math inline">\(nls\)</span>, do R. Esta distingue-se do método LM apenas pelo facto do parâmetro <span class="math inline">\(\mu\)</span> ter um valor nulo, pelo que o método utilizado por esta função é o método de Gauss-Newton. Utilizando os dados definidos anteriormente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="fu">nls</span>(y <span class="sc">~</span> b0<span class="sc">*</span><span class="fu">exp</span>(b1<span class="sc">*</span>x), <span class="at">start =</span> <span class="fu">list</span>(<span class="at">b0 =</span> <span class="dv">170</span>, <span class="at">b1 =</span> <span class="fl">0.0836</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Nonlinear regression model
  model: y ~ b0 * exp(b1 * x)
   data: parent.frame()
       b0        b1 
171.50728   0.08333 
 residual sum-of-squares: 1159

Number of iterations to convergence: 2 
Achieved convergence tolerance: 4.694e-07</code></pre>
</div>
</div>
<p>Os resultados são idênticos, mas tendo em conta o número de iterações, a escolha do valor do parâmetro <span class="math inline">\(\mu\)</span> terá sido conservadora. <!-- levando a uma otimizacao mais lenta --></p>
</section>
<section id="exemplo---regressão-exponencial-problema-não-linear-lm-4" class="slide level2 justify">
<h2>Exemplo - Regressão Exponencial: Problema Não Linear (LM)</h2>

<img data-src="realidadevsLM.png" style="width:100.0%" class="r-stretch quarto-figure-center"><p class="caption">Figura 2: Gráfico dos valores observados para a variável explicativa e resposta, em conjunto com o modelo ajustado.</p></section>
<section id="escolha-da-aproximação-inicial" class="slide level2 justify">
<h2>Escolha da aproximação inicial</h2>
<p>É importante recordar que o método de Levenberg-Marquardt não garante a descoberta do mínimo global. O sucesso da resolução do problema de otimização irá depender da natureza do problema e da qualidade da aproximação inicial escolhida, pelo que se torna essencial uma análise específica do problema.</p>
<p>Caso a aproximação inicial esteja muito longe do mínimo global, o algoritmo pode convergir para um mínimo local, uma solução que é ótima dentro de uma determinada vizinhança, mas pode não ser o ótimo global para toda a região de parâmetros. Isto pode ser resolvido através da seleção de uma aproximação inicial próxima da solução esperada, o que muitas vezes implica um conhecimento à priori ou uma análise minuciosa dos dados.</p>
</section>
<section id="escolha-da-aproximação-inicial-1" class="slide level2 justify">
<h2>Escolha da aproximação inicial</h2>
<p>Uma boa escolha fornece ao algoritmo um ponto de partida próximo da solução ótima, permitindo uma convergência mais rápida. Por outro lado, uma escolha inadequada, que esteja muito longe do mínimo global, leva a uma convergência lenta, aumentando o número de iterações necessárias e a exigência computacional. Para além disso, pode levar o algoritmo a convergir para um mínimo local ou a falhar na convergência.</p>
<p>Apesar de haverem diversos métodos para se obter uma aproximação inicial para o algoritmo, os dois mais comuns são a utilização dos resultados de aproximações lineares, por exemplo através da decomposição QR, ou então por tentativa e erro, isto é, executar o algoritmo de otimização várias vezes com diferentes aproximações iniciais aleatórias, explorando diferentes regiões do espaço de parâmetros, e compararando as mesmas, de modo a reduzir o risco de se obter um mínimo local e não global.</p>
</section>
<section id="escolha-do-parâmetro-mu" class="slide level2 justify">
<h2>Escolha do parâmetro <span class="math inline">\(\mu\)</span></h2>
<p>O valor do parâmetro <span class="math inline">\(\mu\)</span>, frequentemente chamado de termo de amortecimento, no algoritmo de Levenberg-Marquardt, impacta diretamente o termo <span class="math inline">\(\mu I\)</span>, regularizando a matriz Hessiana (<span class="math inline">\(\nabla ^2 g(x)\)</span>) durante a sua inversão, para o cálculo da atualização dos parâmetros do modelo durante a otimização, tornando-a mais estável numericamente.</p>
<p>A seleção do valor para o parâmetro <span class="math inline">\(\mu\)</span> desempenha um papel crucial no comportamento do algoritmo de Levenberg-Marquardt, pelo que a sua escolha deve ser cuidada.</p>
</section>
<section id="escolha-do-parâmetro-mu-1" class="slide level2 justify">
<h2>Escolha do parâmetro <span class="math inline">\(\mu\)</span></h2>
<p>Caso o valor de <span class="math inline">\(\mu\)</span> seja pequeno (<span class="math inline">\(\mu \rightarrow 0\)</span>), o algoritmo de Levenberg-Marquardt assemelha-se ao método de Gauss-Newton. Nesse cenário, a atualização dos parâmetros tem uma maior ponderação da matriz Jacobiana, tornando o processo de otimização menos cuidadoso, o que resulta numa convergência mais rápida.</p>
<p>Quando o valor de <span class="math inline">\(\mu\)</span> é grande (<span class="math inline">\(\mu \rightarrow \infty\)</span>), o comportamento do algoritmo de Levenberg-Marquardt aproxima-se do método de declive máximo. Nesse caso, <span class="math inline">\(\mu I\)</span> torna-se dominante na atualização dos parâmetros, o que resulta num processo de otimização mais cuidadoso em que <span class="math inline">\(x^{(k+1)}\)</span> está próximo de <span class="math inline">\(x^{(k)}\)</span>, aumentando a estabilidade numérica do algoritmo.</p>
</section>
<section id="escolha-do-parâmetro-mu-2" class="slide level2 justify">
<h2>Escolha do parâmetro <span class="math inline">\(\mu\)</span></h2>
<p>Visualize-se o impacto da escolha do parâmetro <span class="math inline">\(\mu\)</span> na resolução do exemplo relativo ao método LM. A aproximação inicial é (<span class="math inline">\(168, 0.0825\)</span>), a condição de paragem é <span class="math inline">\(\|s^{(k)}_{LM}\|_{\infty}&lt;0.5 \times 10^{-3}\)</span> e o parâmetro <span class="math inline">\(\mu\)</span> irá assumir dois valores: um valor grande e um valor pequeno:</p>

<!-- Verifica-se que para $\mu=100$ o algoritmo realiza 54 iterações até verificar a condição de paragem, enquanto que com $\mu=0.01$ o mesmo apenas realiza 3 iterações. -->
<img data-src="LM_miu.png" style="width:100.0%" class="r-stretch quarto-figure-center"><p class="caption">Figura 3: Resíduos em função dos parâmetros a estimar e de <span class="math inline">\(\mu\)</span>.</p></section>
<section id="escolha-do-parâmetro-mu-3" class="slide level2 justify">
<h2>Escolha do parâmetro <span class="math inline">\(\mu\)</span></h2>
<p>A escolha do valor para <span class="math inline">\(\mu\)</span> envolve um equilíbrio entre a velocidade de convergência e a estabilidade numérica do algoritmo, pelo que a sua escolha deve ter em conta as características específicas do problema, não sendo escolhido de forma arbitrária.</p>
<p>Algumas publicações indicam que o parâmetro deve ser escolhido pelo utilizador do algoritmo, outras indicam que o mesmo deve ser atualizado a cada iteração de acordo com o valor de <span class="math inline">\(\| \nabla r(x^{(k)})' r(x^{(k)}) \|\)</span>, há quem indique que se deve começar com um valor pequeno para o parâmetro e dividir ou multiplicar por 10 caso a função objetivo melhore ou piore, respetivamente, etc.</p>
<p>Assim sendo, o método de Levenberg-Marquardt deve atuar mais como o método de declive máximo quando os parâmetros estão longe do seu valor ótimo, e atuar mais como o método de Gauss-Newton quando os parâmetros estão próximos do mesmo.</p>
</section></section>
<section>
<section id="conclusão" class="title-slide slide level1 center">
<h1>Conclusão</h1>

</section>
<section id="conclusão-1" class="slide level2 justify">
<h2>Conclusão</h2>
<p>A realização deste trabalho permitiu a análise da eficiência e da confiabilidade de duas técnicas fundamentais: a decomposição QR e o método de Levenberg-Marquardt, na estimativa de parâmetros para modelos matemáticos, nomeadamente, modelos exponenciais.</p>
<p>Note-se que é de elevada importância relembrar os resultados dos exemplos elaborados. Enquanto que no exemplo associado à decomposição QR se obteve o vetor de parâmetros (<span class="math inline">\(171.0\)</span>, <span class="math inline">\(0.08356\)</span>), no exemplo associado ao método de Levenberg-Marquardt o vetor de parâmetros obtido foi (<span class="math inline">\(171.5\)</span>, <span class="math inline">\(0.08333\)</span>).</p>
</section>
<section id="conclusão-2" class="slide level2 justify">
<h2>Conclusão</h2>
<p>Deve-se portanto, analisar o valor ótimo da função objetivo <span class="math inline">\(g(x)=\frac{1}{2}\sum_{i=1}^{m}r_i(x)^2\)</span> para cada vetor de parâmetros:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> funcao_objetivo(y,x,beta):</span>
<span id="cb11-2"><a href="#cb11-2"></a>    r_i <span class="op">=</span> y <span class="op">-</span> beta[<span class="dv">0</span>]<span class="op">*</span>np.exp(beta[<span class="dv">1</span>]<span class="op">*</span>x)</span>
<span id="cb11-3"><a href="#cb11-3"></a>    valor_otimo <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> np.<span class="bu">sum</span>(r_i<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="cf">return</span> valor_otimo</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>beta_QR, beta_LM <span class="op">=</span> (<span class="fl">171.0</span>, <span class="fl">0.08356</span>), (<span class="fl">171.5</span>, <span class="fl">0.08333</span>)</span>
<span id="cb11-7"><a href="#cb11-7"></a>funcao_objetivo(y,x,beta_QR), funcao_objetivo(y,x,beta_LM)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>(582.0077304979613, 579.6157244799521)</code></pre>
</div>
</div>
<p>Verifica-se que o valor ótimo obtido pelos parâmetros associados à decomposição QR é superior ao valor ótimo obtido pelos parâmetros associados método de Levenberg-Marquardt (<span class="math inline">\(582.0 &gt; 579.6\)</span>), pelo que o método LM efetuou uma otimização mais precisa face à associada à decomposição QR, dado que é um problema de minimização.</p>
</section>
<section id="conclusão-3" class="slide level2 justify">
<h2>Conclusão</h2>
<!-- Visto que ambas as técnicas têm em conta o método dos mínimos quadrados -->
<p>Esta diferença nos resíduos estará associada à precisão numérica da técnica, isto é, pelo facto do algoritmo LM ser de aplicação direta, enquanto que para aplicar a decomposição QR, têm de ser realizadas diversas operações para linearizar a função. Era portanto expectável que a precisão associada à decomposição QR na estimação dos parâmetros fosse menor, devido à propagação do erro.</p>
</section>
<section id="conclusão-4" class="slide level2 justify">
<h2>Conclusão</h2>
<p>A pesquisa sobre a decomposição QR demonstra a sua eficácia, já conhecida, na resolução de sistemas de equações lineares. Através da decomposição da matriz dos coeficientes dos parâmetros a estimar, é possível a agilização do processo de descoberta do vetor de parâmetros ótimo. Este processo torna-se particularmente benéfico quando estamos perante sistemas lineares de maior dimensão.</p>
<p>Contudo, considerando modelos exponenciais, pelo facto de ser necessário linearizar o modelo, a decomposição QR é afetada pela propagação do erro, logo é importante proceder a uma análise crítica dos resultados e considerar métodos de otimização mais avançados.</p>
</section>
<section id="conclusão-5" class="slide level2 justify">
<h2>Conclusão</h2>
<p>De qualquer forma, a utilização desta técnica pode ser extremamente útil para se obter uma aproximação inicial para métodos iterativos como é o caso da segunda técnica utilizada, o método LM.</p>
<p>Tendo em conta o método de Levenberg-Marquardt, pode-se verificar que este é uma interpolação entre o método de Gauss-Newton e o método de declive máximo, ainda que mais robusto que o primeiro. Percebe-se isto quando, na maioria dos casos, é possível obter uma solução mesmo quando se parte de um ponto muito longe do mínimo ótimo, ainda que mais lentamente que o método de Gauss-Newton.</p>
<p>Para além disso, ao analisar os resultados do exemplo relativo a este método, verifica-se que o mesmo é uma ferramenta valiosa para a estimação de parâmetros ótimos em modelos não lineares, nomeadamente modelos exponenciais, destacando a sua robustez e adaptabilidade.</p>

<img src="ualg.png" class="slide-logo r-stretch"><div class="footer footer-default">

</div>
</section></section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="ani_quarto_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="ani_quarto_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="ani_quarto_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="ani_quarto_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': true,
'smaller': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":false},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    
    <script>
      // htmlwidgets need to know to resize themselves when slides are shown/hidden.
      // Fire the "slideenter" event (handled by htmlwidgets.js) when the current
      // slide changes (different for each slide format).
      (function () {
        // dispatch for htmlwidgets
        function fireSlideEnter() {
          const event = window.document.createEvent("Event");
          event.initEvent("slideenter", true, true);
          window.document.dispatchEvent(event);
        }

        function fireSlideChanged(previousSlide, currentSlide) {
          fireSlideEnter();

          // dispatch for shiny
          if (window.jQuery) {
            if (previousSlide) {
              window.jQuery(previousSlide).trigger("hidden");
            }
            if (currentSlide) {
              window.jQuery(currentSlide).trigger("shown");
            }
          }
        }

        // hookup for slidy
        if (window.w3c_slidy) {
          window.w3c_slidy.add_observer(function (slide_num) {
            // slide_num starts at position 1
            fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);
          });
        }

      })();
    </script>

    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
      function tippyHover(el, contentFn) {
        const config = {
          allowHTML: true,
          content: contentFn,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        };
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          return note.innerHTML;
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>